--집합연산자
--UNION - 합집합, UNION ALL - 합집합, INTERSECT - 교집합, MINUS - 차집합


SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--행을 합치고 싶다면 -> 두 문장이 한 문장이 되어야함. 세미콜론 지우고 중간에 UNION이라고 쓰기

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;


SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; --교집합


SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; --차집합

--집합 연산자는 컬럼 수가 일치해야 한다.
--컬럼 수가 일치한다면, 다양한 형태로 사용이 된다.
SELECT '홍길동', TO_CHAR(SYSDATE) FROM DUAL
UNION ALL
SELECT '이순신', '05/01/01' FROM DUAL
UNION ALL
SELECT '홍길자', '06/02/02' FROM DUAL
UNION ALL
SELECT LAST_NAME, TO_CHAR(HIRE_DATE) FROM EMPLOYEES;


------------------------------------------------------------------
--분석함수 - 행에 대한 결과를 출력하는 기능, OVER() 와 함께 사용된다.
SELECT  FIRST_NAME,
        SALARY, 
        RANK() OVER(ORDER BY SALARY DESC) AS 중복순서 ,
        DENSE_RANK() OVER (ORDER BY SALARY DESC) AS 중복순서X,
        ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS 데이터번호, --데이터의 번호
        COUNT(*) OVER(), --전체 데이터 개수 전체 행번호를 컬럼으로 찍어주는 것
        ROWNUM AS 조회순서--조회가 일어난 순서
FROM EMPLOYEES 


